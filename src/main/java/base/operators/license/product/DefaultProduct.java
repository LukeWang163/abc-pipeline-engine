/**
 * Copyright (c) 2013-2018, RapidMiner GmbH, All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under the terms of the
 * GNU Lesser General Public License as published by the Free Software Foundation; either version
 * 3.0 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with this library.
 */
package base.operators.license.product;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import base.operators.license.LicenseManager;

import javax.xml.bind.DatatypeConverter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 * Instances of this class represent a {@link Product} like e.g. RapidMiner or RapidMiner
 * Extensions. Extensions should register an instance of this class to the {@link LicenseManager} if
 * they want to use the license mechanism provided by RapidMiner. After registering the same
 * instance can be used to retrieve the installed licenses for the product.
 *
 * @author Nils Woehler, Marco Boeck
 *
 */
@SuppressWarnings("PMD.GodClass")
public class DefaultProduct implements Product {

	private static final Logger LOGGER = Logger.getLogger(DefaultProduct.class.getSimpleName());

	@JsonIgnore
	private final UUID prodictUUID = UUID.randomUUID();

	private final String productId;

	private final String productVersion;

	private final List<String> supportedVersions;

	private final boolean isExtension;

	@JsonIgnore
	private final String signature;

	private final List<Constraint<?, ?>> constraints;

	/**
	 * @param productId
	 *            the productId should be exactly the same productId that is used to generate
	 *            Licenses for the product. Products IDs for products that are extension (see
	 *            {@link #isExtension()}) are not allowed to start with
	 *            {@link LicenseManager#RAPIDMINER_PRODUCT_ID_PREFIX}.
	 *
	 * @param productVersion
	 *            the version of the product
	 * @param isExtension
	 *            if set to <code>true</code>, this product is flagged as a RapidMiner Studio
	 *            extension
	 * @param signature
	 *            this base64 encoded signature has to be generated by RapidMiner. It is later used
	 *            by the license framework to verify that the product id, the extension flag and the
	 *            constraints have not been tempered with
	 * @param constraints
	 *            the constraints of the product which can be used to restrict features
	 */
	public DefaultProduct(String productId, String productVersion, boolean isExtension, String signature,
			Constraint<?, ?>... constraints) {
		this(productId, productVersion, Arrays.asList(new String[0]), isExtension, signature, constraints);
	}

	/**
	 * @param productId
	 *            the productId should be exactly the same productId that is used to generate
	 *            Licenses for the product. Products IDs for products that are extension (see
	 *            {@link #isExtension()}) are not allowed to start with
	 *            {@link LicenseManager#RAPIDMINER_PRODUCT_ID_PREFIX}.
	 * @param productVersion
	 *            the version of the product
	 * @param supportedVersions
	 *            other supported license versions
	 * @param isExtension
	 *            if set to <code>true</code>, this product is flagged as a RapidMiner Studio
	 *            extension
	 * @param signature
	 *            this base64 encoded signature has to be generated by RapidMiner. It is later used
	 *            by the license framework to verify that the product id, the extension flag and the
	 *            constraints have not been tempered with
	 * @param constraints
	 *            the constraints of the product which can be used to restrict features
	 */
	public DefaultProduct(String productId, String productVersion, List<String> supportedVersions, boolean isExtension,
			String signature, Constraint<?, ?>... constraints) {
		if (productId == null || productId.isEmpty()) {
			throw new IllegalArgumentException("productId must not be null or empty!");
		}
		if (productVersion == null || productVersion.isEmpty()) {
			throw new IllegalArgumentException("productVersion must not be null or empty!");
		}
		if (signature == null || signature.isEmpty()) {
			throw new IllegalArgumentException("signature must not be null or empty!");
		}
		if (constraints == null) {
			throw new IllegalArgumentException("constraints must not be null!");
		}

		this.productId = productId;
		this.productVersion = productVersion;
		this.isExtension = isExtension;
		this.signature = signature;
		this.constraints = Arrays.asList(constraints);
		this.supportedVersions = new ArrayList<>(supportedVersions);
	}

	@Override
	public final String getProductId() {
		return this.productId;
	}

	@Override
	public final String getProductVersion() {
		return this.productVersion;
	}

	@Override
	public List<String> getSupportedVersions() {
		return new ArrayList<>(supportedVersions);
	}

	@Override
	public final UUID getProdictUUID() {
		return this.prodictUUID;
	}

	@Override
	public final List<Constraint<?, ?>> getConstraints() {
		return this.constraints;
	}

	@Override
	public final boolean isExtension() {
		return isExtension;
	}

	@Override
	public String getSignature() {
		return signature;
	}

	@Override
	public final String createBase64Representation() {
		ObjectMapper mapper = new ObjectMapper();
		try {
			String json = mapper.writeValueAsString(this);
			return DatatypeConverter.printBase64Binary(json.getBytes(StandardCharsets.UTF_8));
		} catch (JsonProcessingException e) {
			// we are always in a valid state, so this should not happen
			LOGGER.log(Level.SEVERE, "Error processing Product JSON", e);
			return null;
		}
	}

	@Override
	public final Constraint<?, ?> findConstraint(String constraintId) {
		for (Constraint<?, ?> constr : constraints) {
			if (constr.getKey().equals(constraintId)) {
				return constr;
			}
		}
		return null;
	}

	@Override
	public String toString() {
		return "DefaultProduct [prodictUUID=" + prodictUUID + ", productId=" + productId + ", productVersion="
				+ productVersion + ", supportedVersions=" + supportedVersions + ", isExtension=" + isExtension
				+ ", signature=" + signature + ", constraints=" + constraints + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (constraints == null ? 0 : constraints.hashCode());
		result = prime * result + (isExtension ? 1231 : 1237);
		result = prime * result + (prodictUUID == null ? 0 : prodictUUID.hashCode());
		result = prime * result + (productId == null ? 0 : productId.hashCode());
		result = prime * result + (productVersion == null ? 0 : productVersion.hashCode());
		result = prime * result + (signature == null ? 0 : signature.hashCode());
		result = prime * result + (supportedVersions == null ? 0 : supportedVersions.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		DefaultProduct other = (DefaultProduct) obj;
		if (constraints == null) {
			if (other.constraints != null) {
				return false;
			}
		} else if (!constraints.equals(other.constraints)) {
			return false;
		}
		if (isExtension != other.isExtension) {
			return false;
		}
		if (prodictUUID == null) {
			if (other.prodictUUID != null) {
				return false;
			}
		} else if (!prodictUUID.equals(other.prodictUUID)) {
			return false;
		}
		if (productId == null) {
			if (other.productId != null) {
				return false;
			}
		} else if (!productId.equals(other.productId)) {
			return false;
		}
		if (productVersion == null) {
			if (other.productVersion != null) {
				return false;
			}
		} else if (!productVersion.equals(other.productVersion)) {
			return false;
		}
		if (signature == null) {
			if (other.signature != null) {
				return false;
			}
		} else if (!signature.equals(other.signature)) {
			return false;
		}
		if (supportedVersions == null) {
			if (other.supportedVersions != null) {
				return false;
			}
		} else if (!supportedVersions.equals(other.supportedVersions)) {
			return false;
		}
		return true;
	}

}
